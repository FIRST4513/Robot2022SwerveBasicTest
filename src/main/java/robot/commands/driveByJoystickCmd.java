// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package robot.commands;
import robot.RobotContainer;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import robot.Constants.DriveTrainConstants;
import robot.Constants.OIConstants;

import robot.subsystems.drivetrainSubSys;


public class driveByJoystickCmd extends CommandBase {

    private final drivetrainSubSys m_drivetrainSubSys;
    private Joystick m_joystick;
    private Translation2d translation;
    private boolean fieldRelative = false;

    public driveByJoystickCmd(drivetrainSubSys subsystem) {
        m_drivetrainSubSys = subsystem;
        addRequirements(m_drivetrainSubSys);

    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        m_joystick = RobotContainer.getInstance().getdriverJoy();
    }


    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        double wheelAngle = 0;
        double wheelRotation = 0;

        // Step 1 - Get joystick Inputs
        // Step 1a) Get joystick inputs from individual axis
            double xSpeed = -m_joystick.getY();      // NOTE: xSpeed (Fwd/Back) comes from Y axis
            double ySpeed = m_joystick.getX();     // NOTE: ySpeed (Left/Right) comes from X axis
            double rotation = m_joystick.getTwist();

            double throttle = (-m_joystick.getThrottle()/2) + 0.5; // convert from ( -1:1 ) to ( 0:1 ) 
            SmartDashboard.putNumber("Joy Drive xSpeed Raw 1", xSpeed);
            SmartDashboard.putNumber("Joy Drive ySpeed Raw 1", ySpeed);
            SmartDashboard.putNumber("Joy Rotation Raw 1", rotation);

        // Step 1b) Apply deadband (in case joystick doesn't return fully to Zero position)
            xSpeed = deadBand(xSpeed);  // Not Used in this program
            ySpeed = deadBand(ySpeed);
            rotation = deadBand(rotation);
            //SmartDashboard.putNumber("Joy Drive ySpeed Raw 2", ySpeed);

        // Step 1c) Limit Speeds based on throttle setting
            xSpeed *= throttle;  // Not Used in this program
            ySpeed *= throttle;
            rotation *= throttle;
            SmartDashboard.putNumber("Joy Drive ySpeed Raw 3", ySpeed);
            SmartDashboard.putNumber("Joy Drive ySpeed Raw 3", xSpeed);
            SmartDashboard.putNumber("Joy Rotation Raw 3", rotation);

        // Step 2a - Convert Joystick values to Field Velocity (Meters/Sec)
            xSpeed *= DriveTrainConstants.kTeleDriveMaxSpeedMetersPerSecond;  // Not Used in this program
            ySpeed *= DriveTrainConstants.kTeleDriveMaxSpeedMetersPerSecond;
            wheelRotation = rotation * DriveTrainConstants.kTeleDriveMaxAngularSpeedRadiansPerSecond;

            SmartDashboard.putNumber("Joy Drive ySpeed Meters", ySpeed);
            SmartDashboard.putNumber("Joy Drive xSpeed Meters", xSpeed);
            SmartDashboard.putNumber("Joy Rotation Speed", wheelRotation);


        // Step 2b - Convert Joystick angle -1 to +1  into -PI cw to +PI ccw
            wheelAngle *= Math.PI;
            SmartDashboard.putNumber("Joy Wheel Angle Radians", wheelAngle);
            SmartDashboard.putNumber("Joy Wheel Angle Degrees", Math.toDegrees(wheelAngle));
            // Step 2b - Convert Joystick angle -1 to +1  into -180 cw to +180 ccw
            //    wheelAngle = (wheelAngle * -180.0);


        // Send raw data to swerve module (Speed Meters/Sec , Wheel Angle Radians)
        // 
        if (m_joystick.getRawButton(5)){
            // Maual Drive Front Left Wheel
            m_drivetrainSubSys.setSingleModuleState(
                    DriveTrainConstants.kFrontLeftDriveMotorPort, xSpeed, wheelAngle);
        } else if (m_joystick.getRawButton(6)){
            // Maual Drive Front Right Wheel
            m_drivetrainSubSys.setSingleModuleState(
                    DriveTrainConstants.kFrontRightDriveMotorPort, xSpeed, wheelAngle);
        } else if (m_joystick.getRawButton(3)){
            // Maual Drive Back Left Wheel
            m_drivetrainSubSys.setSingleModuleState(
                    DriveTrainConstants.kBackLeftDriveMotorPort, xSpeed, wheelAngle);
        } else if (m_joystick.getRawButton(4)){
            // Maual Drive Back Right Wheel
            m_drivetrainSubSys.setSingleModuleState(
                    DriveTrainConstants.kBackRightDriveMotorPort, xSpeed, wheelAngle);
        } else if (m_joystick.getRawButton(1)){
            // Maual Drive All Wheels
            m_drivetrainSubSys.setSingleModuleState(
                    DriveTrainConstants.kFrontLeftDriveMotorPort, xSpeed, wheelAngle);
            m_drivetrainSubSys.setSingleModuleState(
                    DriveTrainConstants.kFrontRightDriveMotorPort, xSpeed, wheelAngle);
            m_drivetrainSubSys.setSingleModuleState(
                    DriveTrainConstants.kBackLeftDriveMotorPort, xSpeed, wheelAngle);
            m_drivetrainSubSys.setSingleModuleState(
                    DriveTrainConstants.kBackRightDriveMotorPort, xSpeed, wheelAngle);
        } else if (m_joystick.getRawButton(7)){
            // Drive All wheels using Chassis Speeds Kinematics
            translation = new Translation2d(xSpeed, ySpeed);
            if (m_joystick.getRawButton(2)){
                fieldRelative = true;
            } else {
                fieldRelative = false;
            }
            m_drivetrainSubSys.drive(translation, wheelRotation, fieldRelative, false);
        } else {
             // Stop al Motion
             m_drivetrainSubSys.stopModules();           
        }
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_drivetrainSubSys.stopModules();
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    public double deadBand(double value){
        // Deadband Calculation
        if((value <=  OIConstants.kDeadband) && (value >= - OIConstants.kDeadband)){
            return 0;
        }
        if (value > 0) {
            value=(value - OIConstants.kDeadband) * (1 + OIConstants.kDeadband);		// Scale Yvalue smoothly to + 1
        } else {
            value = - (-value - OIConstants.kDeadband) * (1 + OIConstants.kDeadband);	// Scale Yvalue smoothly to -1
        }
        return value;
    }


    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
